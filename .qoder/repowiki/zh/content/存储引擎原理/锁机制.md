# 锁机制

<cite>
**本文档引用的文件**
- [Table.java](file://src/main/java/io/leavesfly/smallsql/rdb/engine/Table.java)
- [TableStorePage.java](file://src/main/java/io/leavesfly/smallsql/rdb/engine/store/TableStorePage.java)
- [SsConnection.java](file://src/main/java/io/leavesfly/smallsql/jdbc/SsConnection.java)
- [RowSource.java](file://src/main/java/io/leavesfly/smallsql/rdb/engine/RowSource.java)
- [StoreImpl.java](file://src/main/java/io/leavesfly/smallsql/rdb/engine/store/StoreImpl.java)
</cite>

## 目录
1. [锁机制概述](#锁机制概述)
2. [表级锁](#表级锁)
3. [页级锁](#页级锁)
4. [行级锁](#行级锁)
5. [事务协调](#事务协调)
6. [隔离级别与锁行为](#隔离级别与锁行为)
7. [死锁检测与处理](#死锁检测与处理)
8. [锁竞争与性能优化](#锁竞争与性能优化)

## 锁机制概述

SmallSQL数据库系统实现了多粒度锁机制，包括表级锁、页级锁和行级锁，以实现并发控制。该机制通过`Table`类、`StorePage`类和`SsConnection`类协同工作，确保在多用户环境下数据的一致性和完整性。锁的获取和释放遵循严格的规则，以防止死锁并优化性能。

**Section sources**
- [Table.java](file://src/main/java/io/leavesfly/smallsql/rdb/engine/Table.java#L68-L99)
- [SsConnection.java](file://src/main/java/io/leavesfly/smallsql/jdbc/SsConnection.java#L76-L120)

## 表级锁

表级锁由`Table`类管理，用于控制对整个表的访问。当执行DDL操作（如CREATE、ALTER）时，需要获取表级锁。`Table`类中的`tabLockConnection`字段记录了持有表锁的连接，`tabLockCount`记录了锁的计数。通过`requestLock`方法，连接可以请求表级锁，如果已有其他连接持有锁，则请求将被拒绝。

```mermaid
classDiagram
class Table {
-HashMap<Long, TableStorePage> locks
-SsConnection tabLockConnection
-int tabLockCount
-ArrayList<TableStorePage> locksInsert
-HashMap<SsConnection, SsConnection> serializeConnections
+requestLock(SsConnection, int, long) TableStorePage
+freeLock(TableStorePage) void
}
class SsConnection {
-List<TransactionStep> commitPages
+add(TransactionStep) void
+commit() void
+rollback() void
}
Table --> SsConnection : "持有"
```

**Diagram sources**
- [Table.java](file://src/main/java/io/leavesfly/smallsql/rdb/engine/Table.java#L68-L99)
- [SsConnection.java](file://src/main/java/io/leavesfly/smallsql/jdbc/SsConnection.java#L76-L120)

**Section sources**
- [Table.java](file://src/main/java/io/leavesfly/smallsql/rdb/engine/Table.java#L378-L418)
- [Table.java](file://src/main/java/io/leavesfly/smallsql/rdb/engine/Table.java#L526-L573)

## 页级锁

页级锁由`TableStorePage`类实现，用于管理对数据页的并发访问。每个`TableStorePage`对象代表一个数据页的锁，包含`lockType`（锁类型）、`con`（持有锁的连接）和`nextLock`（锁链表的下一个锁）等字段。`Table`类通过`locks`哈希表管理所有页级锁，确保同一页面不会被多个连接同时修改。

```mermaid
classDiagram
class TableStorePage {
+Table table
+int lockType
+SsConnection con
+TableStorePage nextLock
+TableStorePage(SsConnection, Table, int, long)
+commit() long
+freeLock() void
}
class StorePage {
+byte[] page
+int pageSize
+long fileOffset
+StorePage(byte[], int, FileChannel, long)
+commit() long
+rollback() void
}
TableStorePage --|> StorePage
```

**Diagram sources**
- [TableStorePage.java](file://src/main/java/io/leavesfly/smallsql/rdb/engine/store/TableStorePage.java#L36-L78)
- [StorePage.java](file://src/main/java/io/leavesfly/smallsql/rdb/engine/store/StorePage.java#L35-L56)

**Section sources**
- [Table.java](file://src/main/java/io/leavesfly/smallsql/rdb/engine/Table.java#L325-L376)
- [Table.java](file://src/main/java/io/leavesfly/smallsql/rdb/engine/Table.java#L452-L484)

## 行级锁

行级锁通过`RowSource`接口和`StoreImpl`类实现，提供对单行数据的精细控制。`RowSource`是所有数据源的抽象基类，定义了行导航方法。`StoreImpl`类通过`createWriteLock`方法实现行级写锁的升级，允许在读取行后升级为写锁，以支持更新操作。

```mermaid
classDiagram
class RowSource {
+isScrollable() boolean
+beforeFirst() void
+next() boolean
+getRow() int
+getRowPosition() long
+setRowPosition(long) void
}
class StoreImpl {
+storePage StorePage
+createWriteLock() void
+deleteRow(SsConnection) void
+updateRow(Expression[]) void
}
class TableResult {
+table Table
+store Store
+insertStorePages List<StorePageLink>
}
RowSource <|-- TableResult
TableResult --> StoreImpl : "使用"
```

**Diagram sources**
- [RowSource.java](file://src/main/java/io/leavesfly/smallsql/rdb/engine/RowSource.java#L0-L189)
- [StoreImpl.java](file://src/main/java/io/leavesfly/smallsql/rdb/engine/store/StoreImpl.java#L276-L290)

**Section sources**
- [StoreImpl.java](file://src/main/java/io/leavesfly/smallsql/rdb/engine/store/StoreImpl.java#L276-L290)
- [TableResult.java](file://src/main/java/io/leavesfly/smallsql/rdb/engine/selector/result/TableResult.java#L68-L130)

## 事务协调

`SsConnection`类负责在事务中协调锁的获取与释放。每个连接维护一个`commitPages`列表，记录了事务中所有已获取的锁。在提交事务时，系统会依次提交所有锁对应的页面，然后释放锁；在回滚事务时，会回滚所有页面并释放锁。这种机制确保了事务的原子性和一致性。

```mermaid
sequenceDiagram
participant Client as "客户端"
participant Connection as "SsConnection"
participant Table as "Table"
participant StorePage as "TableStorePage"
Client->>Connection : 执行SQL操作
Connection->>Table : requestLock()
Table->>Table : 检查锁冲突
Table-->>Connection : 返回TableStorePage
Connection->>Connection : add()到commitPages
Connection->>StorePage : 执行数据操作
Client->>Connection : commit()
Connection->>StorePage : commit()所有页面
Connection->>StorePage : freeLock()释放锁
Connection-->>Client : 提交成功
```

**Diagram sources**
- [SsConnection.java](file://src/main/java/io/leavesfly/smallsql/jdbc/SsConnection.java#L256-L283)
- [SsConnection.java](file://src/main/java/io/leavesfly/smallsql/jdbc/SsConnection.java#L319-L371)

**Section sources**
- [SsConnection.java](file://src/main/java/io/leavesfly/smallsql/jdbc/SsConnection.java#L208-L254)
- [SsConnection.java](file://src/main/java/io/leavesfly/smallsql/jdbc/SsConnection.java#L256-L283)

## 隔离级别与锁行为

SmallSQL支持多种事务隔离级别，不同级别下锁的行为有所不同。在`TRANSACTION_SERIALIZABLE`级别，系统会将连接添加到`serializeConnections`集合中，严格限制并发操作。在较低隔离级别，系统会根据`isolationLevel`字段的值调整锁的获取策略，以平衡一致性和性能。

```mermaid
flowchart TD
Start([开始]) --> CheckIsolation["检查隔离级别"]
CheckIsolation --> |SERIALIZABLE| AddToSerialize["添加到serializeConnections"]
CheckIsolation --> |READ_COMMITTED| CheckWriteLock["检查写锁"]
CheckIsolation --> |READ_UNCOMMITTED| AllowRead["允许读取未提交数据"]
AddToSerialize --> RequestLock["请求锁"]
CheckWriteLock --> RequestLock
AllowRead --> RequestLock
RequestLock --> AcquireLock["获取锁"]
AcquireLock --> End([结束])
```

**Diagram sources**
- [Table.java](file://src/main/java/io/leavesfly/smallsql/rdb/engine/Table.java#L325-L376)
- [Table.java](file://src/main/java/io/leavesfly/smallsql/rdb/engine/Table.java#L415-L456)

**Section sources**
- [Table.java](file://src/main/java/io/leavesfly/smallsql/rdb/engine/Table.java#L325-L376)
- [TestTransactions.java](file://src/test/java/io/leavesfly/smallsql/junit/sql/tpl/TestTransactions.java#L428-L461)

## 死锁检测与处理

系统通过超时机制检测和处理死锁。在`requestLock`方法中，如果在5秒内无法获取锁，系统会抛出`TABLE_DEADLOCK`异常。`locks.wait(waitTime)`方法实现了等待逻辑，`endTime`变量记录了超时时间。这种机制防止了无限等待，确保系统在出现死锁时能够及时恢复。

```mermaid
flowchart TD
Start([请求锁]) --> CheckFile["检查文件状态"]
CheckFile --> |文件无效| ThrowException["抛出TABLE_MODIFIED异常"]
CheckFile --> |文件有效| SetEndTime["设置超时时间"]
SetEndTime --> TryAcquire["尝试获取锁"]
TryAcquire --> |获取成功| ReturnLock["返回StorePage"]
TryAcquire --> |获取失败| CheckTimeout["检查是否超时"]
CheckTimeout --> |未超时| Wait["等待"]
Wait --> TryAcquire
CheckTimeout --> |已超时| ThrowDeadlock["抛出TABLE_DEADLOCK异常"]
```

**Diagram sources**
- [Table.java](file://src/main/java/io/leavesfly/smallsql/rdb/engine/Table.java#L325-L376)
- [Table.java](file://src/main/java/io/leavesfly/smallsql/rdb/engine/Table.java#L526-L573)

**Section sources**
- [Table.java](file://src/main/java/io/leavesfly/smallsql/rdb/engine/Table.java#L325-L376)
- [TestTransactions.java](file://src/test/java/io/leavesfly/smallsql/junit/sql/tpl/TestTransactions.java#L493-L511)

## 锁竞争与性能优化

为减少锁竞争，系统采用了多种优化策略。页级锁的链表结构允许同一连接在不同操作中重用锁。`requestWriteLock`方法支持从读锁升级到写锁，避免了重复获取锁的开销。此外，系统通过`locksInsert`列表管理插入操作的锁，减少了对主锁表的竞争。

```mermaid
graph TB
subgraph "锁管理"
A[表级锁] --> B[页级锁]
B --> C[行级锁]
end
subgraph "优化策略"
D[锁重用] --> E[减少锁获取]
F[锁升级] --> G[避免重复获取]
H[分离插入锁] --> I[减少竞争]
end
A --> D
B --> F
C --> H
```

**Diagram sources**
- [Table.java](file://src/main/java/io/leavesfly/smallsql/rdb/engine/Table.java#L486-L524)
- [Table.java](file://src/main/java/io/leavesfly/smallsql/rdb/engine/Table.java#L279-L323)

**Section sources**
- [Table.java](file://src/main/java/io/leavesfly/smallsql/rdb/engine/Table.java#L486-L524)
- [Table.java](file://src/main/java/io/leavesfly/smallsql/rdb/engine/Table.java#L279-L323)