# 关键设计模式

<cite>
**本文档中引用的文件**   
- [Command.java](file://src/main/java/io/leavesfly/smallsql/rdb/command/Command.java)
- [CommandSelect.java](file://src/main/java/io/leavesfly/smallsql/rdb/command/dql/CommandSelect.java)
- [SQLParser.java](file://src/main/java/io/leavesfly/smallsql/rdb/sql/SQLParser.java)
- [StoreImpl.java](file://src/main/java/io/leavesfly/smallsql/rdb/engine/store/StoreImpl.java)
- [Store.java](file://src/main/java/io/leavesfly/smallsql/rdb/engine/Store.java)
- [SsDriver.java](file://src/main/java/io/leavesfly/smallsql/SsDriver.java)
</cite>

## 目录
1. [命令模式](#命令模式)
2. [工厂模式](#工厂模式)
3. [装饰器模式](#装饰器模式)
4. [单例模式](#单例模式)

## 命令模式

命令模式在SmallSQL中通过Command抽象类实现，为DDL、DML和DQL操作提供了统一的处理框架。Command类作为所有SQL命令的基类，定义了executeImpl()模板方法，该方法在execute()方法中被调用。execute()方法实现了事务控制逻辑，包括保存点设置、异常回滚和自动提交处理，而具体的命令执行逻辑则由子类通过重写executeImpl()方法来实现。

Command类提供了参数管理、结果集处理和更新计数等通用功能。子类如CommandSelect、CommandInsert等继承Command类并实现executeImpl()方法，以处理特定类型的SQL语句。这种设计使得不同类型的SQL命令可以遵循相同的执行流程，同时保持各自的执行逻辑。

```mermaid
classDiagram
class Command {
+int type
+String catalog
+String name
+SsResultSet rs
+int updateCount
+Expressions columnExpressions
+Expressions params
+Logger log
+Command(Logger log)
+Command(Logger log, Expressions columnExpressions)
+addColumnExpression(Expression column) void
+addParameter(ExpressionValue param) void
+verifyParams() void
+clearParams() void
+setParamValue(int idx, Object value, int dataType) void
+setParamValue(int idx, Object value, int dataType, int length) void
+execute(SsConnection con, SsStatement st) void
+executeImpl(SsConnection con, SsStatement st) void
+getQueryResult() SsResultSet
+getResultSet() SsResultSet
+getUpdateCount() int
+getMoreResults() boolean
+setMaxRows(int max) void
+getMaxRows() int
}
class CommandSelect {
-DataSources tables
-Expression where
-RowSource from
-Expressions groupBy
-Expression having
-Expressions orderBy
-boolean isAggregateFunction
-int maxRows
-boolean isDistinct
+CommandSelect(Logger log)
+CommandSelect(Logger log, Expressions columnExpressions)
+compile(SsConnection con) boolean
+isGroupResult() boolean
+executeImpl(SsConnection con, SsStatement st) void
+beforeFirst() void
+isBeforeFirst() boolean
+isFirst() boolean
+first() boolean
+previous() boolean
+next() boolean
+last() boolean
+afterLast() void
+isLast() boolean
+isAfterLast() boolean
+absolute(int row) boolean
+relative(int rows) boolean
+getRow() int
+updateRow(SsConnection con, Expression[] newRowSources) void
+insertRow(SsConnection con, Expression[] newRowSources) void
+deleteRow(SsConnection con) void
+findColumn(String columnName) int
+setDistinct(boolean distinct) void
+setSource(RowSource join) void
+setTables(DataSources from) void
+setWhere(Expression where) void
+setGroup(Expressions group) void
+setHaving(Expression having) void
+setOrder(Expressions order) void
+setMaxRows(int max) void
+getMaxRows() int
}
class CommandInsert {
-String tableName
-boolean noColumns
-Expressions values
+CommandInsert(Logger log, String tableName)
+addValues(Expressions values) void
+addValues(CommandSelect select) void
+addColumnExpression(Expression column) void
+executeImpl(SsConnection con, SsStatement st) void
}
class CommandUpdate {
-DataSources tables
-RowSource from
-Expressions settings
+CommandUpdate(Logger log)
+setTables(DataSources tables) void
+setSource(RowSource from) void
+addSetting(Expression dest, Expression src) void
+executeImpl(SsConnection con, SsStatement st) void
}
class CommandDelete {
-DataSources tables
-RowSource from
-Expression where
+CommandDelete(Logger log)
+setTables(DataSources tables) void
+setSource(RowSource from) void
+setWhere(Expression where) void
+executeImpl(SsConnection con, SsStatement st) void
}
Command <|-- CommandSelect
Command <|-- CommandInsert
Command <|-- CommandUpdate
Command <|-- CommandDelete
```

**图源**
- [Command.java](file://src/main/java/io/leavesfly/smallsql/rdb/command/Command.java#L47-L190)
- [CommandSelect.java](file://src/main/java/io/leavesfly/smallsql/rdb/command/dql/CommandSelect.java#L61-L587)

**节源**
- [Command.java](file://src/main/java/io/leavesfly/smallsql/rdb/command/Command.java#L47-L190)
- [CommandSelect.java](file://src/main/java/io/leavesfly/smallsql/rdb/command/dql/CommandSelect.java#L61-L587)

## 工厂模式

工厂模式在SQLParser类中得到应用，根据SQL语句类型创建具体的Command子类实例。SQLParser的parse()方法作为工厂方法，根据SQL语句的第一个关键字（如SELECT、INSERT、UPDATE等）来决定创建哪种类型的Command对象。这种设计将对象的创建逻辑集中在一个类中，使得系统更容易扩展和维护。

当解析到不同的SQL语句时，SQLParser会调用相应的私有方法（如select()、insert()、update()等）来创建具体的Command实例。例如，当解析到SELECT语句时，会创建CommandSelect实例；当解析到INSERT语句时，会创建CommandInsert实例。这种工厂模式的实现使得添加新的SQL语句类型变得简单，只需在SQLParser中添加相应的解析方法和Command子类即可。

```mermaid
sequenceDiagram
participant Client as "客户端"
participant SQLParser as "SQLParser"
participant Command as "Command"
participant CommandSelect as "CommandSelect"
participant CommandInsert as "CommandInsert"
participant CommandUpdate as "CommandUpdate"
participant CommandDelete as "CommandDelete"
Client->>SQLParser : parse(con, sqlString)
SQLParser->>SQLParser : parse(sql)
SQLParser->>SQLParser : nextToken()
alt SELECT语句
SQLParser->>SQLParser : select()
SQLParser->>SQLParser : singleSelect()
SQLParser->>CommandSelect : new CommandSelect(log)
CommandSelect-->>SQLParser : CommandSelect实例
SQLParser-->>Client : CommandSelect
else INSERT语句
SQLParser->>SQLParser : insert()
SQLParser->>CommandInsert : new CommandInsert(log, tableName)
CommandInsert-->>SQLParser : CommandInsert实例
SQLParser-->>Client : CommandInsert
else UPDATE语句
SQLParser->>SQLParser : update()
SQLParser->>CommandUpdate : new CommandUpdate(log)
CommandUpdate-->>SQLParser : CommandUpdate实例
SQLParser-->>Client : CommandUpdate
else DELETE语句
SQLParser->>SQLParser : delete()
SQLParser->>CommandDelete : new CommandDelete(log)
CommandDelete-->>SQLParser : CommandDelete实例
SQLParser-->>Client : CommandDelete
end
```

**图源**
- [SQLParser.java](file://src/main/java/io/leavesfly/smallsql/rdb/sql/SQLParser.java#L137-L2527)

**节源**
- [SQLParser.java](file://src/main/java/io/leavesfly/smallsql/rdb/sql/SQLParser.java#L137-L2527)

## 装饰器模式

装饰器模式在Store类层次结构中体现，特别是StoreImpl如何增强基础Store功能。Store是一个抽象类，定义了数据存储的基本操作接口，如读取不同类型的数据、获取页面状态等。StoreImpl类继承Store并提供了具体的实现，同时通过组合的方式增强了基础Store的功能。

StoreImpl不仅实现了Store定义的抽象方法，还提供了额外的功能，如页面管理、数据写入、事务处理等。通过StoreImpl，系统可以对数据存储进行更精细的控制，如页面大小管理、数据压缩、缓存等。这种装饰器模式的设计使得可以在不修改原有Store类的情况下，通过继承和组合的方式添加新的功能，提高了代码的灵活性和可扩展性。

```mermaid
classDiagram
class Store {
<<abstract>>
+static final Store NULL
+static final Store NOROW
+isNull(int offset) boolean
+getBoolean(int offset, int dataType) boolean
+getBytes(int offset, int dataType) byte[]
+getDouble(int offset, int dataType) double
+getFloat(int offset, int dataType) float
+getInt(int offset, int dataType) int
+getLong(int offset, int dataType) long
+getMoney(int offset, int dataType) long
+getNumeric(int offset, int dataType) MutableNumeric
+getObject(int offset, int dataType) Object
+getString(int offset, int dataType) String
+isValidPage() boolean
+scanObjectOffsets(int[] offsets, int dataTypes[]) void
+getUsedSize() int
+getNextPagePos() long
+deleteRow(SsConnection con) void
}
class StoreImpl {
-static final int DEFAULT_PAGE_SIZE
-static final int PAGE_MAGIC
-static final int PAGE_CONTROL_SIZE
-static final byte[] page_control
-static final ByteBuffer pageControlBuffer
-int status
-static final int NORMAL
-static final int DELETED
-static final int UPDATE_POINTER
-static final int UPDATED_PAGE
-Table table
-byte[] page
-boolean sharedPageData
-StorePage storePage
-long filePos
-int sizeUsed
-int sizePhysical
-int nextPageOffset
-long filePosUpdated
-int type
-StoreImpl updatePointer
+createStore(Table table, StorePage storePage, int type, long filePos) StoreImpl
+recreateStore(Table table, StorePage storePage, int type) StoreImpl
+readPageHeader() void
+loadUpdatedStore() StoreImpl
+resizePage(int minNewSize) void
+isValidPage() boolean
+getUsedSize() int
+getNextPagePos() long
+writeFinsh(SsConnection con) long
+createWriteLock() void
+updateFinsh(SsConnection con, StoreImpl newData) void
+getCurrentOffsetInPage() int
+setCurrentOffsetInPage(int newOffset) void
+writeByte(int value) void
+readByte() int
+readUnsignedByte() int
+writeBoolean(boolean value) void
+readBoolean() boolean
+writeShort(int value) void
+readShort() int
+writeInt(int value) void
+readInt() int
+writeLong(long value) void
+readLong() long
+writeDouble(double value) void
+readDouble() double
+writeFloat(float value) void
+readFloat() float
+writeNumeric(MutableNumeric num) void
+readNumeric() MutableNumeric
+writeTimestamp(long ts) void
+readTimestamp() long
+writeTime(long time) void
+readTime() long
+writeDate(long date) void
+readDate() long
+writeSmallDateTime(long datetime) void
+readSmallDateTime() long
+writeString(String strDaten) void
+writeString(String strDaten, int lengthColumn, boolean varchar) void
+readString() String
+writeBytes(byte[] daten) void
+writeBytes(byte[] daten, int off, int length) void
+readBytes(int length) byte[]
+writeBinary(byte[] daten, int lengthColumn, boolean varBinary) void
+readBinary() byte[]
+writeLongBinary(byte[] daten) void
+readLongBinary() byte[]
+writeChars(char[] daten) void
+readChars(int length) char[]
+writeLongString(String daten) void
+readLongString() String
+writeColumn(Column column) void
+readColumn(int tableFormatVersion) Column
+copyValueFrom(StoreImpl store, int valueOffset, int length) void
+writeExpression(Expression expr, Column column) void
}
class StoreNull {
+isNull(int offset) boolean
+getBoolean(int offset, int dataType) boolean
+getBytes(int offset, int dataType) byte[]
+getDouble(int offset, int dataType) double
+getFloat(int offset, int dataType) float
+getInt(int offset, int dataType) int
+getLong(int offset, int dataType) long
+getMoney(int offset, int dataType) long
+getNumeric(int offset, int dataType) MutableNumeric
+getObject(int offset, int dataType) Object
+getString(int offset, int dataType) String
+isValidPage() boolean
+scanObjectOffsets(int[] offsets, int dataTypes[]) void
+getUsedSize() int
+getNextPagePos() long
+deleteRow(SsConnection con) void
}
class StoreNoCurrentRow {
+isNull(int offset) boolean
+getBoolean(int offset, int dataType) boolean
+getBytes(int offset, int dataType) byte[]
+getDouble(int offset, int dataType) double
+getFloat(int offset, int dataType) float
+getInt(int offset, int dataType) int
+getLong(int offset, int dataType) long
+getMoney(int offset, int dataType) long
+getNumeric(int offset, int dataType) MutableNumeric
+getObject(int offset, int dataType) Object
+getString(int offset, int dataType) String
+isValidPage() boolean
+scanObjectOffsets(int[] offsets, int dataTypes[]) void
+getUsedSize() int
+getNextPagePos() long
+deleteRow(SsConnection con) void
}
Store <|-- StoreImpl
Store <|-- StoreNull
Store <|-- StoreNoCurrentRow
```

**图源**
- [Store.java](file://src/main/java/io/leavesfly/smallsql/rdb/engine/Store.java#L45-L90)
- [StoreImpl.java](file://src/main/java/io/leavesfly/smallsql/rdb/engine/store/StoreImpl.java#L0-L799)

**节源**
- [Store.java](file://src/main/java/io/leavesfly/smallsql/rdb/engine/Store.java#L45-L90)
- [StoreImpl.java](file://src/main/java/io/leavesfly/smallsql/rdb/engine/store/StoreImpl.java#L0-L799)

## 单例模式

单例模式在SsDriver类中实现，确保在整个应用程序中只有一个SsDriver实例。SsDriver类通过静态代码块在类加载时创建并注册驱动程序实例，保证了实例的唯一性。DRIVER静态字段持有SsDriver的唯一实例，客户端通过DriverManager获取连接时，实际上使用的是同一个SsDriver实例。

这种单例模式的实现方式确保了数据库驱动程序的全局唯一性，避免了多个实例可能带来的资源浪费和状态不一致问题。同时，静态初始化的方式保证了线程安全，因为在类加载过程中，JVM会确保静态代码块只执行一次。

```mermaid
classDiagram
class SsDriver {
+static final String URL_PREFIX
+static SsDriver DRIVER
+connect(String url, Properties info) Connection
+parse(String url, Properties info) Properties
+acceptsURL(String url) boolean
+getPropertyInfo(String url, Properties info) DriverPropertyInfo[]
+getMajorVersion() int
+getMinorVersion() int
+jdbcCompliant() boolean
+getParentLogger() Logger
}
class DriverManager {
+registerDriver(Driver driver) void
+getConnection(String url) Connection
}
SsDriver --> DriverManager : "注册"
Client --> DriverManager : "获取连接"
DriverManager --> SsDriver : "使用驱动"
```

**图源**
- [SsDriver.java](file://src/main/java/io/leavesfly/smallsql/SsDriver.java#L52-L202)

**节源**
- [SsDriver.java](file://src/main/java/io/leavesfly/smallsql/SsDriver.java#L52-L202)